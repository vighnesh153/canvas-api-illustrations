{"version":3,"sources":["illustrations/brick-breaker/controller.ts","illustrations/brick-breaker/component.tsx","illustrations/brick-breaker/index.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","models/canvas.ts"],"names":["Brick","canvas","x","y","exists","this","width","height","color","drawFilledRect","BrickBreakerController","e","interval","setTimeout","playerScore","gameRunning","backgroundColor","homeScreenTextColor","userScoreColor","paddleWidth","paddleHeight","paddleColor","bricks","paddle","ballVelocityX","ballVelocityY","ballOriginalX","ballOriginalY","ball","velocityX","velocityY","previousBallPosition","Canvas","initializeBricks","i","push","j","reset","setInterval","render","bind","clearInterval","start","event","getBoundingClientRect","root","document","documentElement","clientX","left","scrollLeft","boundXCoordinate","Math","min","max","drawBackground","renderGame","updateGameState","renderStartScreen","drawBricks","drawPaddle","drawBall","writeScore","handleCollision","handleWallCollision","handleCollisionWithPaddle","handleCollisionWithBricks","stop","brickX","floor","brickY","forEach","r","b","draw","t1","writeText","t2","Component","props","setDataAttributes","canvasEl","canvasRef","current","component","focus","tabIndex","addEventListener","key","onEnterPress","onHover","connect","dispatch","v","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_createClass","protoProps","staticProps","prototype","canvasContext","drawBitmap","drawOutlineRect","drawLine","drawFilledCircle","getContext","setTransform","useBitmap","angle","save","translate","rotate","drawImage","restore","fillStyle","fillRect","strokeStyle","strokeRect","radius","beginPath","moveTo","arcTo","stroke","x1","y1","x2","y2","lineWidth","lineTo","dashParams","setLineDash","centerX","centerY","arc","PI","fill","text","fontSize","fillText"],"mappings":"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","file":"static/js/4.37edd228.chunk.js","sourcesContent":["import Canvas from \"src/models/canvas\";\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\nclass Brick {\n  static readonly width = 15;\n  static readonly height = 7;\n\n  static readonly color = \"blue\";\n\n  exists = true;\n\n  constructor(public canvas: Canvas, public x: number, public y: number) {}\n\n  draw() {\n    if (!this.exists) {\n      return;\n    }\n    const { width, height, color } = Brick;\n    this.canvas.drawFilledRect(\n      this.y * width,\n      this.x * height,\n      width - 1,\n      height - 1,\n      color\n    );\n  }\n}\n\nexport class BrickBreakerController {\n  private readonly canvas: Canvas;\n  private interval = setTimeout(() => {}, 0);\n\n  private playerScore = 0;\n\n  private gameRunning = false;\n\n  private readonly backgroundColor = \"white\";\n  private readonly homeScreenTextColor = \"black\";\n  private readonly userScoreColor = \"green\";\n\n  paddleWidth = 50;\n  paddleHeight = 3;\n  paddleColor = \"black\";\n\n  private bricks: Brick[][] = [];\n  private paddle: Point = { x: 0, y: 250 };\n\n  private ballVelocityX = 2;\n  private ballVelocityY = 1;\n\n  ballOriginalX = 250;\n  ballOriginalY = 150;\n  private ball = {\n    x: this.ballOriginalX,\n    y: this.ballOriginalY,\n    width: 5,\n    height: 5,\n    velocityX: this.ballVelocityX,\n    velocityY: this.ballVelocityY,\n    color: \"red\",\n  };\n\n  private previousBallPosition: Point | null = null;\n\n  constructor(e: HTMLCanvasElement) {\n    this.canvas = new Canvas(e);\n  }\n\n  reset() {\n    this.playerScore = 0;\n    this.paddle.x = (this.canvas.width - this.paddleWidth) / 2;\n    this.ball.x = this.ballOriginalX;\n    this.ball.y = this.ballOriginalY;\n    this.ball.velocityX = this.ballVelocityX;\n    this.ball.velocityY = this.ballVelocityY;\n    this.previousBallPosition = null;\n    this.initializeBricks();\n  }\n\n  initializeBricks() {\n    const { width } = this.canvas;\n    this.bricks = [];\n\n    for (let i = 0; i < 20; i++) {\n      this.bricks.push([]);\n      for (let j = 0; j < width / Brick.width; j++) {\n        this.bricks[i].push(new Brick(this.canvas, i, j));\n      }\n    }\n\n    // Create gutter\n    for (let i = 0; i < 5; i++) {\n      for (let j = 0; j < width / Brick.width; j++) {\n        this.bricks[i][j].exists = false;\n      }\n    }\n  }\n\n  start() {\n    this.reset();\n    this.interval = setInterval(this.render.bind(this), 16);\n  }\n\n  stop() {\n    this.gameRunning = false;\n    clearInterval(this.interval);\n    this.render();\n  }\n\n  onEnterPress() {\n    if (!this.gameRunning) {\n      this.playerScore = 0;\n      this.start();\n    }\n    this.gameRunning = true;\n  }\n\n  onHover(event: MouseEvent) {\n    if (this.canvas) {\n      const canvas = this.canvas.getBoundingClientRect;\n      const root = document.documentElement;\n      this.paddle.x =\n        event.clientX - canvas.left - root.scrollLeft - this.paddleWidth / 2;\n      this.boundXCoordinate();\n    }\n  }\n\n  boundXCoordinate() {\n    const { width } = this.canvas;\n    const { paddleWidth, paddle } = this;\n    paddle.x = Math.min(paddle.x, width - paddleWidth);\n    paddle.x = Math.max(paddle.x, 0);\n  }\n\n  render() {\n    this.drawBackground();\n    if (this.gameRunning) {\n      this.renderGame();\n      this.updateGameState();\n    } else {\n      this.renderStartScreen();\n      clearInterval(this.interval);\n    }\n  }\n\n  private drawBackground() {\n    const { backgroundColor } = this;\n    const { width, height } = this.canvas;\n\n    this.canvas.drawFilledRect(0, 0, width, height, backgroundColor);\n  }\n\n  private renderGame() {\n    this.drawBricks();\n    this.drawPaddle();\n    this.drawBall();\n    this.writeScore();\n  }\n\n  private updateGameState() {\n    this.ball.x += this.ball.velocityX;\n    this.ball.y += this.ball.velocityY;\n\n    this.handleCollision();\n  }\n\n  private handleCollision() {\n    this.handleWallCollision();\n    this.handleCollisionWithPaddle();\n    this.handleCollisionWithBricks();\n  }\n\n  private handleWallCollision() {\n    if (\n      this.ball.x + this.ball.width >= this.canvas.width ||\n      this.ball.x <= 0\n    ) {\n      this.ball.velocityX *= -1;\n    }\n\n    if (this.ball.y <= 0) {\n      this.ball.velocityY *= -1;\n    }\n\n    if (this.ball.y >= this.canvas.height) {\n      this.stop();\n    }\n  }\n\n  private handleCollisionWithPaddle() {\n    const { x, y } = this.ball;\n\n    if (x >= this.paddle.x && x <= this.paddle.x + this.paddleWidth) {\n      if (y >= this.paddle.y && y <= this.paddle.y + this.paddleHeight) {\n        this.ball.velocityY *= -1;\n      }\n    }\n  }\n\n  private handleCollisionWithBricks() {\n    const { x, y } = this.ball;\n\n    const brickX = Math.floor(y / Brick.height);\n    const brickY = Math.floor(x / Brick.width);\n\n    if (\n      this.bricks[brickX] &&\n      this.bricks[brickX][brickY] &&\n      this.bricks[brickX][brickY].exists\n    ) {\n      this.bricks[brickX][brickY].exists = false;\n      this.playerScore++;\n\n      if (this.previousBallPosition) {\n        if (this.previousBallPosition.x !== brickX) {\n          this.ball.velocityY *= -1;\n        }\n        if (this.previousBallPosition.y !== brickY) {\n          this.ball.velocityX *= -1;\n        }\n      }\n    }\n\n    this.previousBallPosition = {\n      x: brickX,\n      y: brickY,\n    };\n  }\n\n  private drawBricks() {\n    this.bricks.forEach((r) => r.forEach((b) => b.draw()));\n  }\n\n  private drawPaddle() {\n    const { paddleWidth, paddleHeight, paddleColor, paddle } = this;\n    const { x, y } = paddle;\n\n    this.canvas.drawFilledRect(x, y, paddleWidth, paddleHeight, paddleColor);\n  }\n\n  private drawBall() {\n    const { x, y, width, height, color } = this.ball;\n\n    this.canvas.drawFilledRect(x, y, width, height, color);\n  }\n\n  private writeScore() {\n    const t1 = `Your score: ${this.playerScore}`;\n    const { userScoreColor } = this;\n\n    this.canvas.writeText(t1, 10, 14, 16, userScoreColor);\n  }\n\n  private renderStartScreen() {\n    const t1 = \"Click on the canvas and hit 'Enter' to start\";\n\n    const { homeScreenTextColor, userScoreColor } = this;\n    const { height } = this.canvas;\n\n    this.canvas.writeText(t1, 150, height / 2, 25, homeScreenTextColor);\n\n    const t2 = `Your score: ${this.playerScore}`;\n    this.canvas.writeText(t2, 210, 180, 20, userScoreColor);\n  }\n}\n","import React from \"react\";\nimport DataAttributes from \"src/models/data-attributes\";\nimport { BrickBreakerController } from \"src/illustrations/brick-breaker/controller\";\n\ntype PropsType = {\n  canvasRef: React.RefObject<HTMLCanvasElement>;\n  setDataAttributes: (v: DataAttributes) => void;\n};\n\nfunction Component(props: PropsType) {\n  // remove all the attributes from other non-game components\n  props.setDataAttributes({});\n\n  const canvasEl = props.canvasRef.current as HTMLCanvasElement;\n  const component = new BrickBreakerController(canvasEl);\n  canvasEl.focus();\n  canvasEl.tabIndex = 1;\n  component.start();\n\n  canvasEl.addEventListener(\"keyup\", (event) => {\n    if (event.key === \"Enter\") {\n      component.onEnterPress();\n    }\n  });\n\n  canvasEl.addEventListener(\"mousemove\", (event: MouseEvent) => {\n    component.onHover(event);\n  });\n\n  return <></>;\n}\n\nexport default Component;\n","import { Dispatch } from \"redux\";\nimport { connect } from \"react-redux\";\n\nimport DataAttributes from \"src/models/data-attributes\";\nimport { setDataAttributes } from \"src/redux-impl/data-attributes/actions\";\n\nimport Component from \"./component\";\n\nfunction mapDispatchToProps(dispatch: Dispatch) {\n  return {\n    setDataAttributes: (v: DataAttributes) => dispatch(setDataAttributes(v)),\n  };\n}\n\nexport default connect(null, mapDispatchToProps)(Component);\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default class Canvas {\n    private canvas: HTMLCanvasElement;\n    private canvasContext: CanvasRenderingContext2D;\n\n    get getBoundingClientRect() {\n        return this.canvas.getBoundingClientRect();\n    }\n\n    get width(): number {\n        return this.canvas.width;\n    }\n\n    get height(): number {\n        return this.canvas.height;\n    }\n\n    constructor(canvas: HTMLCanvasElement) {\n        this.drawBitmap = this.drawBitmap.bind(this);\n        this.drawFilledRect = this.drawFilledRect.bind(this);\n        this.drawOutlineRect = this.drawOutlineRect.bind(this);\n        this.drawLine = this.drawLine.bind(this);\n        this.drawFilledCircle = this.drawFilledCircle.bind(this);\n        this.drawBitmap = this.drawBitmap.bind(this);\n        this.writeText = this.writeText.bind(this);\n\n        this.canvas = canvas;\n        this.canvasContext =\n            this.canvas.getContext('2d') as CanvasRenderingContext2D;\n        this.reset();\n    }\n\n    reset() {\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n    }\n\n    drawBitmap(useBitmap: CanvasImageSource, x: number, y: number, angle: number) {\n        this.canvasContext.save();\n        this.canvasContext.translate(x, y);\n        this.canvasContext.rotate(angle);\n        this.canvasContext.drawImage(useBitmap, -useBitmap.width / 2, -useBitmap.height / 2);\n        this.canvasContext.restore();\n    }\n\n    drawFilledRect(x: number, y: number, width: number, height: number, color: string) {\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.fillRect(x, y, width, height);\n    }\n\n    drawOutlineRect(x: number, y: number, width: number, height: number, color: string) {\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.strokeRect(x, y, width, height);\n    }\n\n    drawRoundedRect(\n        x: number, y: number, width: number, height: number, radius: number, color: string\n    ) {\n        this.canvasContext.beginPath();\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.moveTo(x + width - radius, y + height);\n        this.canvasContext.arcTo(x, y + height, x, y, radius);\n        this.canvasContext.arcTo(x, y, x + width, y, radius);\n        this.canvasContext.arcTo(x + width, y, x + width, y + height, radius);\n        this.canvasContext.arcTo(x + width, y + height, x, y + height, radius);\n        this.canvasContext.stroke();\n    }\n\n    drawLine(x1: number, y1: number, x2: number, y2: number, lineWidth: number, color: string) {\n        this.canvasContext.save();\n        this.canvasContext.beginPath();\n        this.canvasContext.lineWidth = lineWidth;\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.moveTo(x1, y1);\n        this.canvasContext.lineTo(x2, y2);\n        this.canvasContext.stroke();\n        this.canvasContext.restore();\n    }\n\n    drawDashedLine(x1: number, y1: number, x2: number, y2: number, lineWidth: number, color: string, dashParams: number[]) {\n        this.canvasContext.setLineDash(dashParams);\n        this.drawLine(x1, y1, x2, y2, lineWidth, color);\n        this.canvasContext.setLineDash([]);\n    }\n\n    drawFilledCircle(centerX: number, centerY: number, radius: number, color: string) {\n        this.canvasContext.beginPath();\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.arc(centerX, centerY, radius, 0, 2 * Math.PI, true);\n        this.canvasContext.fill();\n    }\n\n    writeText(text: string, x: number, y: number, fontSize: number, color: string) {\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.fillText(text, x, y);\n    }\n\n    translate(x: number, y: number) {\n        this.canvasContext.translate(x, y);\n    }\n\n    rotate(angle: number) {\n        this.canvasContext.rotate(angle);\n    }\n\n    pushState() {\n        this.canvasContext.save();\n    }\n\n    popState() {\n        this.canvasContext.restore();\n    }\n}\n\n\n// Mouse handler\n// let mouseX, mouseY;\n// canvas-container.addEventListener('mousemove', function (event) {\n//         let rect = canvas-container.getBoundingClientRect();\n//         let root = document.documentElement;\n\n//         mouseX = event.clientX - rect.left - root.scrollLeft;\n//         mouseY = event.clientY - rect.top - root.scrollTop;\n//     });\n"],"sourceRoot":""}