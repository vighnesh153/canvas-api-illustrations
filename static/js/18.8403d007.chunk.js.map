{"version":3,"sources":["illustrations/flappy-block-game/controller.ts","illustrations/flappy-block-game/component.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","models/canvas.ts"],"names":["Pipe","canvas","x","y","height","passedBlock","safeToRemoveFromArray","b","this","width","p","topLeft","topRight","bottomLeft","bottomRight","pointInside","bind","velocityX","drawFilledRect","color","FlappyBlockGameController","e","interval","setTimeout","playerScore","gameRunning","distanceBetweenVerticalPipes","backgroundColor","outlineColor","homeScreenTextColor","scoreColor","offset","frameCounter","gravity","blockOriginalVelocity","block","velocityY","pipes","pipesAppearAfterNFrames","Canvas","reset","start","setInterval","render","resetBlockPosition","clearInterval","drawBackground","renderGame","updateGameState","renderStartScreen","drawBlock","drawPipes","writeScore","collidesWithSkyOrFellsDown","updatePipes","addPipes","stop","t1","writeText","drawLine","heightOfUpperPipe","Math","floor","random","startYofLowerPipe","push","forEach","pipe","update","behind","collidesWith","filter","draw","Component","props","canvasEl","canvasRef","current","gameController","focus","tabIndex","addEventListener","event","code","onSpacePress","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","canvasContext","drawBitmap","drawOutlineRect","drawFilledCircle","getContext","getBoundingClientRect","setTransform","useBitmap","angle","save","translate","rotate","drawImage","restore","fillStyle","fillRect","strokeStyle","strokeRect","radius","beginPath","moveTo","arcTo","stroke","x1","y1","x2","y2","lineWidth","lineTo","dashParams","setLineDash","centerX","centerY","arc","PI","fill","text","fontSize","fillText"],"mappings":"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","file":"static/js/18.8403d007.chunk.js","sourcesContent":["import Canvas from \"src/models/canvas\";\n\nclass Pipe {\n  private static velocityX = 3;\n  private static width = 30;\n  private static color = \"blue\";\n\n  passedBlock = false;\n  safeToRemoveFromArray = false;\n\n  constructor(\n    private canvas: Canvas,\n    private x: number,\n    private y: number,\n    private height: number\n  ) {}\n\n  behind(b: { x: number }) {\n    return this.x + Pipe.width < b.x;\n  }\n\n  pointInside(p: { x: number; y: number }) {\n    if (p.x >= this.x && p.x <= this.x + Pipe.width) {\n      return p.y >= this.y && p.y <= this.y + this.height;\n    }\n    return false;\n  }\n\n  collidesWith(b: { x: number; y: number; width: number; height: number }) {\n    const topLeft = { x: b.x, y: b.y };\n    const topRight = { x: b.x + b.width, y: b.y };\n    const bottomLeft = { x: b.x, y: b.y + b.height };\n    const bottomRight = { x: b.x + b.width, y: b.y + b.height };\n    const pointInside = this.pointInside.bind(this);\n\n    return (\n      pointInside(topLeft) ||\n      pointInside(topRight) ||\n      pointInside(bottomLeft) ||\n      pointInside(bottomRight)\n    );\n  }\n\n  update() {\n    this.x -= Pipe.velocityX;\n    this.safeToRemoveFromArray = this.x + Pipe.width <= 0;\n  }\n\n  draw() {\n    this.canvas.drawFilledRect(\n      this.x,\n      this.y,\n      Pipe.width,\n      this.height,\n      Pipe.color\n    );\n  }\n}\n\nexport class FlappyBlockGameController {\n  private readonly canvas: Canvas;\n  private interval = setTimeout(() => {}, 0);\n\n  private playerScore = 0;\n\n  private gameRunning = false;\n\n  private distanceBetweenVerticalPipes = 100;\n\n  private readonly backgroundColor = \"white\";\n  private readonly outlineColor = \"black\";\n  private readonly homeScreenTextColor = \"black\";\n  private readonly scoreColor = \"green\";\n\n  private readonly offset = 20;\n  private frameCounter = 0;\n\n  private gravity = 0.08;\n  private blockOriginalVelocity = 0.1;\n  private block = {\n    x: 0,\n    y: 0,\n    width: 10,\n    height: 10,\n    color: \"red\",\n    velocityY: 0,\n  };\n\n  private pipes: Pipe[] = [];\n  private pipesAppearAfterNFrames = 80;\n\n  constructor(e: HTMLCanvasElement) {\n    this.canvas = new Canvas(e);\n    this.reset();\n  }\n\n  onSpacePress() {\n    if (!this.gameRunning) {\n      this.gameRunning = true;\n      this.reset();\n      this.pipes = [];\n      this.start();\n    } else {\n      this.block.velocityY = -2;\n    }\n  }\n\n  start() {\n    this.interval = setInterval(this.render.bind(this), 16);\n  }\n\n  reset() {\n    this.resetBlockPosition();\n    this.block.velocityY = this.blockOriginalVelocity;\n    this.playerScore = 0;\n    this.frameCounter = 0;\n  }\n\n  resetBlockPosition() {\n    this.block.x = ((this.canvas.width * 2) / 3 - this.block.width) / 2;\n    this.block.y = (this.canvas.height - this.block.height) / 2;\n  }\n\n  stop() {\n    this.gameRunning = false;\n    clearInterval(this.interval);\n    this.resetBlockPosition();\n    this.render();\n  }\n\n  render() {\n    this.drawBackground();\n    if (this.gameRunning) {\n      this.renderGame();\n      this.updateGameState();\n    } else {\n      this.renderStartScreen();\n      clearInterval(this.interval);\n    }\n  }\n\n  renderGame() {\n    this.drawBlock();\n    this.drawPipes();\n    this.writeScore();\n  }\n\n  updateGameState() {\n    this.block.y += this.block.velocityY;\n    this.block.velocityY += this.gravity;\n\n    this.collidesWithSkyOrFellsDown();\n    this.updatePipes();\n\n    this.frameCounter++;\n    if (this.frameCounter === this.pipesAppearAfterNFrames) {\n      this.addPipes();\n      this.frameCounter %= this.pipesAppearAfterNFrames;\n    }\n  }\n\n  collidesWithSkyOrFellsDown() {\n    const { y, height } = this.block;\n    if (y <= this.offset) {\n      // collided with sky\n      this.stop();\n    } else if (y + height >= this.canvas.height - this.offset) {\n      // fell down\n      this.stop();\n    }\n  }\n\n  renderStartScreen() {\n    const t1 = `Your score: ${this.playerScore}`;\n    const t2 = \"Hit 'SPACEBAR' to start and jump.\";\n\n    const { scoreColor, homeScreenTextColor } = this;\n    const { width, height } = this.canvas;\n    const x = width / 2;\n    const y = height / 2;\n\n    this.drawBlock();\n\n    this.canvas.writeText(t1, x - 50, y + 20, 25, scoreColor);\n    this.canvas.writeText(t2, x - 100, y + 50, 25, homeScreenTextColor);\n  }\n\n  writeScore() {\n    const t1 = `Your score: ${this.playerScore}`;\n    const { homeScreenTextColor } = this;\n\n    this.canvas.writeText(t1, this.offset + 10, 16, 18, homeScreenTextColor);\n  }\n\n  drawBackground() {\n    const { offset, backgroundColor, outlineColor, canvas } = this;\n    const { width, height } = canvas;\n\n    canvas.drawFilledRect(0, 0, width, height, backgroundColor);\n    canvas.drawLine(0, offset, width, offset, 1, outlineColor);\n    canvas.drawLine(\n      0,\n      height - offset,\n      width,\n      height - offset,\n      1,\n      outlineColor\n    );\n  }\n\n  drawBlock() {\n    const { x, y, width, height, color } = this.block;\n    this.canvas.drawFilledRect(x, y, width, height, color);\n  }\n\n  addPipes() {\n    const { canvas, distanceBetweenVerticalPipes, offset } = this;\n    const heightOfUpperPipe = 30 + Math.floor(Math.random() * 130);\n    const startYofLowerPipe = heightOfUpperPipe + distanceBetweenVerticalPipes;\n\n    this.pipes.push(\n      new Pipe(canvas, canvas.width, offset, heightOfUpperPipe - offset)\n    );\n    this.pipes.push(\n      new Pipe(\n        canvas,\n        canvas.width,\n        startYofLowerPipe,\n        canvas.height - startYofLowerPipe - offset\n      )\n    );\n  }\n\n  updatePipes() {\n    this.pipes.forEach((pipe) => {\n      pipe.update();\n      if (pipe.behind(this.block)) {\n        if (!pipe.passedBlock) {\n          // We add 0.5 because 2 pipes are there. 1 horizontal & 1 vertical\n          this.playerScore += 0.5;\n        }\n        pipe.passedBlock = true;\n      }\n      if (pipe.collidesWith(this.block)) {\n        this.stop();\n      }\n    });\n    this.pipes = this.pipes.filter((p) => !p.safeToRemoveFromArray);\n  }\n\n  drawPipes() {\n    this.pipes.forEach((pipe) => pipe.draw());\n  }\n}\n","import React from \"react\";\nimport DataAttributes from \"src/models/data-attributes\";\nimport { FlappyBlockGameController } from \"./controller\";\n\ntype PropsType = {\n  canvasRef: React.RefObject<HTMLCanvasElement>;\n  setDataAttributes: (v: DataAttributes) => void;\n};\n\nfunction Component(props: PropsType) {\n  const canvasEl = props.canvasRef.current as HTMLCanvasElement;\n  const gameController = new FlappyBlockGameController(canvasEl);\n  canvasEl.focus();\n  canvasEl.tabIndex = 1;\n  gameController.start();\n\n  canvasEl.addEventListener(\"keyup\", (event) => {\n    if (event.code === \"Space\") {\n      gameController.onSpacePress();\n    }\n  });\n\n  return <></>;\n}\n\nexport default Component;\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default class Canvas {\n    private canvas: HTMLCanvasElement;\n    private canvasContext: CanvasRenderingContext2D;\n\n    get getBoundingClientRect() {\n        return this.canvas.getBoundingClientRect();\n    }\n\n    get width(): number {\n        return this.canvas.width;\n    }\n\n    get height(): number {\n        return this.canvas.height;\n    }\n\n    constructor(canvas: HTMLCanvasElement) {\n        this.drawBitmap = this.drawBitmap.bind(this);\n        this.drawFilledRect = this.drawFilledRect.bind(this);\n        this.drawOutlineRect = this.drawOutlineRect.bind(this);\n        this.drawLine = this.drawLine.bind(this);\n        this.drawFilledCircle = this.drawFilledCircle.bind(this);\n        this.drawBitmap = this.drawBitmap.bind(this);\n        this.writeText = this.writeText.bind(this);\n\n        this.canvas = canvas;\n        this.canvasContext =\n            this.canvas.getContext('2d') as CanvasRenderingContext2D;\n        this.reset();\n    }\n\n    reset() {\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n    }\n\n    drawBitmap(useBitmap: CanvasImageSource, x: number, y: number, angle: number) {\n        this.canvasContext.save();\n        this.canvasContext.translate(x, y);\n        this.canvasContext.rotate(angle);\n        this.canvasContext.drawImage(useBitmap, -useBitmap.width / 2, -useBitmap.height / 2);\n        this.canvasContext.restore();\n    }\n\n    drawFilledRect(x: number, y: number, width: number, height: number, color: string) {\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.fillRect(x, y, width, height);\n    }\n\n    drawOutlineRect(x: number, y: number, width: number, height: number, color: string) {\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.strokeRect(x, y, width, height);\n    }\n\n    drawRoundedRect(\n        x: number, y: number, width: number, height: number, radius: number, color: string\n    ) {\n        this.canvasContext.beginPath();\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.moveTo(x + width - radius, y + height);\n        this.canvasContext.arcTo(x, y + height, x, y, radius);\n        this.canvasContext.arcTo(x, y, x + width, y, radius);\n        this.canvasContext.arcTo(x + width, y, x + width, y + height, radius);\n        this.canvasContext.arcTo(x + width, y + height, x, y + height, radius);\n        this.canvasContext.stroke();\n    }\n\n    drawLine(x1: number, y1: number, x2: number, y2: number, lineWidth: number, color: string) {\n        this.canvasContext.save();\n        this.canvasContext.beginPath();\n        this.canvasContext.lineWidth = lineWidth;\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.moveTo(x1, y1);\n        this.canvasContext.lineTo(x2, y2);\n        this.canvasContext.stroke();\n        this.canvasContext.restore();\n    }\n\n    drawDashedLine(x1: number, y1: number, x2: number, y2: number, lineWidth: number, color: string, dashParams: number[]) {\n        this.canvasContext.setLineDash(dashParams);\n        this.drawLine(x1, y1, x2, y2, lineWidth, color);\n        this.canvasContext.setLineDash([]);\n    }\n\n    drawFilledCircle(centerX: number, centerY: number, radius: number, color: string) {\n        this.canvasContext.beginPath();\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.arc(centerX, centerY, radius, 0, 2 * Math.PI, true);\n        this.canvasContext.fill();\n    }\n\n    writeText(text: string, x: number, y: number, fontSize: number, color: string) {\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.fillText(text, x, y);\n    }\n\n    translate(x: number, y: number) {\n        this.canvasContext.translate(x, y);\n    }\n\n    rotate(angle: number) {\n        this.canvasContext.rotate(angle);\n    }\n\n    pushState() {\n        this.canvasContext.save();\n    }\n\n    popState() {\n        this.canvasContext.restore();\n    }\n}\n\n\n// Mouse handler\n// let mouseX, mouseY;\n// canvas-container.addEventListener('mousemove', function (event) {\n//         let rect = canvas-container.getBoundingClientRect();\n//         let root = document.documentElement;\n\n//         mouseX = event.clientX - rect.left - root.scrollLeft;\n//         mouseY = event.clientY - rect.top - root.scrollTop;\n//     });\n"],"sourceRoot":""}