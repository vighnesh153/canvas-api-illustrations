{"version":3,"sources":["illustrations/pseudo-hilbert-curve/controller.ts","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","models/canvas.ts"],"names":["Point","x","y","HilbertCurveController","canvasElement","order","stopper","canvas","lineThickness","squaresCount","totalPoints","done","hilbertIndices","points","framesCounter","this","Canvas","drawFilledRect","width","height","Array","generatePoints","index","ref","firstOrderPoint","j","length","i","point","getHilbertIndex","prev","min","Math","current","drawLine","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","canvasContext","drawBitmap","bind","drawOutlineRect","drawFilledCircle","writeText","getContext","reset","getBoundingClientRect","setTransform","useBitmap","angle","save","translate","rotate","drawImage","restore","color","fillStyle","fillRect","strokeStyle","strokeRect","radius","beginPath","moveTo","arcTo","stroke","x1","y1","x2","y2","lineWidth","lineTo","dashParams","setLineDash","centerX","centerY","arc","PI","fill","text","fontSize","fillText"],"mappings":"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","file":"static/js/28.c8bd4726.chunk.js","sourcesContent":["import Canvas from \"src/models/canvas\";\n\nclass Point {\n  constructor(public x: number, public y: number) {}\n}\n\nexport default class HilbertCurveController {\n  canvas: Canvas;\n\n  order: number;\n  lineThickness = 1;\n  squaresCount: number;\n  totalPoints: number;\n\n  done = false;\n\n  hilbertIndices: Point[] = [\n    new Point(0, 0),\n    new Point(0, 1),\n    new Point(1, 1),\n    new Point(1, 0),\n  ];\n\n  points: Point[];\n  framesCounter = 0;\n\n  stopper: () => void;\n\n  constructor(\n    canvasElement: HTMLCanvasElement,\n    order: number,\n    stopper: () => void\n  ) {\n    this.canvas = new Canvas(canvasElement);\n    // Draw background\n    this.canvas.drawFilledRect(\n      0,\n      0,\n      this.canvas.width,\n      this.canvas.height,\n      \"white\"\n    );\n\n    this.order = order;\n    this.squaresCount = 2 ** order;\n    this.totalPoints = this.squaresCount ** 2;\n    this.points = new Array(this.totalPoints);\n    this.stopper = stopper;\n    this.generatePoints();\n  }\n\n  getHilbertIndex(index: number) {\n    const ref = this.hilbertIndices[index & 3];\n    const firstOrderPoint = new Point(ref.x, ref.y);\n\n    for (let j = 1; j < this.order; j++) {\n      index >>= 2;\n      const length = 2 ** j;\n\n      switch (index & 3) {\n        case 0:\n          [firstOrderPoint.x, firstOrderPoint.y] = [\n            firstOrderPoint.y,\n            firstOrderPoint.x,\n          ];\n          break;\n        case 1:\n          firstOrderPoint.y += length;\n          break;\n        case 2:\n          firstOrderPoint.x += length;\n          firstOrderPoint.y += length;\n          break;\n        case 3:\n          [firstOrderPoint.x, firstOrderPoint.y] = [\n            length - 1 - firstOrderPoint.y,\n            length - 1 - firstOrderPoint.x,\n          ];\n          firstOrderPoint.x += length;\n      }\n    }\n\n    return firstOrderPoint;\n  }\n\n  generatePoints() {\n    const length = this.canvas.height / this.squaresCount;\n\n    for (let i = 0; i < this.totalPoints; i++) {\n      const point = this.getHilbertIndex(i);\n      point.x *= length;\n      point.y *= length;\n\n      // Offset\n      point.x += (this.canvas.width - length * (this.squaresCount - 1)) / 2;\n      point.y += (this.canvas.height - length * (this.squaresCount - 1)) / 2;\n\n      this.points[i] = point;\n    }\n  }\n\n  plot() {\n    if (this.done) {\n      return;\n    }\n    let prev = this.points[0];\n    const { min } = Math;\n\n    for (let i = 1; i < min(this.framesCounter, this.points.length); i++) {\n      const current = this.points[i];\n      this.canvas.drawLine(\n        prev.x,\n        prev.y,\n        current.x,\n        current.y,\n        this.lineThickness,\n        \"darkblue\"\n      );\n      prev = current;\n    }\n  }\n\n  update() {\n    if (this.done) {\n      return;\n    }\n    this.framesCounter++;\n    if (this.framesCounter > this.points.length) {\n      this.done = true;\n      this.points = [];\n    }\n  }\n}\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default class Canvas {\n    private canvas: HTMLCanvasElement;\n    private canvasContext: CanvasRenderingContext2D;\n\n    get getBoundingClientRect() {\n        return this.canvas.getBoundingClientRect();\n    }\n\n    get width(): number {\n        return this.canvas.width;\n    }\n\n    get height(): number {\n        return this.canvas.height;\n    }\n\n    constructor(canvas: HTMLCanvasElement) {\n        this.drawBitmap = this.drawBitmap.bind(this);\n        this.drawFilledRect = this.drawFilledRect.bind(this);\n        this.drawOutlineRect = this.drawOutlineRect.bind(this);\n        this.drawLine = this.drawLine.bind(this);\n        this.drawFilledCircle = this.drawFilledCircle.bind(this);\n        this.drawBitmap = this.drawBitmap.bind(this);\n        this.writeText = this.writeText.bind(this);\n\n        this.canvas = canvas;\n        this.canvasContext =\n            this.canvas.getContext('2d') as CanvasRenderingContext2D;\n        this.reset();\n    }\n\n    reset() {\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n    }\n\n    drawBitmap(useBitmap: CanvasImageSource, x: number, y: number, angle: number) {\n        this.canvasContext.save();\n        this.canvasContext.translate(x, y);\n        this.canvasContext.rotate(angle);\n        this.canvasContext.drawImage(useBitmap, -useBitmap.width / 2, -useBitmap.height / 2);\n        this.canvasContext.restore();\n    }\n\n    drawFilledRect(x: number, y: number, width: number, height: number, color: string) {\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.fillRect(x, y, width, height);\n    }\n\n    drawOutlineRect(x: number, y: number, width: number, height: number, color: string) {\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.strokeRect(x, y, width, height);\n    }\n\n    drawRoundedRect(\n        x: number, y: number, width: number, height: number, radius: number, color: string\n    ) {\n        this.canvasContext.beginPath();\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.moveTo(x + width - radius, y + height);\n        this.canvasContext.arcTo(x, y + height, x, y, radius);\n        this.canvasContext.arcTo(x, y, x + width, y, radius);\n        this.canvasContext.arcTo(x + width, y, x + width, y + height, radius);\n        this.canvasContext.arcTo(x + width, y + height, x, y + height, radius);\n        this.canvasContext.stroke();\n    }\n\n    drawLine(x1: number, y1: number, x2: number, y2: number, lineWidth: number, color: string) {\n        this.canvasContext.save();\n        this.canvasContext.beginPath();\n        this.canvasContext.lineWidth = lineWidth;\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.moveTo(x1, y1);\n        this.canvasContext.lineTo(x2, y2);\n        this.canvasContext.stroke();\n        this.canvasContext.restore();\n    }\n\n    drawDashedLine(x1: number, y1: number, x2: number, y2: number, lineWidth: number, color: string, dashParams: number[]) {\n        this.canvasContext.setLineDash(dashParams);\n        this.drawLine(x1, y1, x2, y2, lineWidth, color);\n        this.canvasContext.setLineDash([]);\n    }\n\n    drawFilledCircle(centerX: number, centerY: number, radius: number, color: string) {\n        this.canvasContext.beginPath();\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.arc(centerX, centerY, radius, 0, 2 * Math.PI, true);\n        this.canvasContext.fill();\n    }\n\n    writeText(text: string, x: number, y: number, fontSize: number, color: string) {\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.fillText(text, x, y);\n    }\n\n    translate(x: number, y: number) {\n        this.canvasContext.translate(x, y);\n    }\n\n    rotate(angle: number) {\n        this.canvasContext.rotate(angle);\n    }\n\n    pushState() {\n        this.canvasContext.save();\n    }\n\n    popState() {\n        this.canvasContext.restore();\n    }\n}\n\n\n// Mouse handler\n// let mouseX, mouseY;\n// canvas-container.addEventListener('mousemove', function (event) {\n//         let rect = canvas-container.getBoundingClientRect();\n//         let root = document.documentElement;\n\n//         mouseX = event.clientX - rect.left - root.scrollLeft;\n//         mouseY = event.clientY - rect.top - root.scrollTop;\n//     });\n"],"sourceRoot":""}