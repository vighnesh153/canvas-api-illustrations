{"version":3,"sources":["illustrations/pseudo-hilbert-curve/index.ts","illustrations/pseudo-hilbert-curve/controller.ts","illustrations/pseudo-hilbert-curve/component.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","models/canvas.ts"],"names":["connect","dispatch","setDataAttributes","v","Component","Point","x","y","HilbertCurveController","canvasElement","order","stopper","canvas","lineThickness","squaresCount","totalPoints","done","hilbertIndices","points","framesCounter","this","Canvas","drawFilledRect","width","height","Array","generatePoints","index","ref","firstOrderPoint","j","length","i","point","getHilbertIndex","prev","min","Math","current","drawLine","props","canvasRef","canvasEl","isAnimating","useRef","animationStart","animate","program","animationStop","plot","update","requestAnimationFrame","id","window","cancelAnimationFrame","dataAttributes","numberInputs","title","note","max","step","currentValue","onChange","value","setTimeout","useEffect","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","canvasContext","drawBitmap","bind","drawOutlineRect","drawFilledCircle","writeText","getContext","reset","getBoundingClientRect","setTransform","useBitmap","angle","save","translate","rotate","drawImage","restore","color","fillStyle","fillRect","strokeStyle","strokeRect","radius","beginPath","moveTo","arcTo","stroke","x1","y1","x2","y2","lineWidth","lineTo","dashParams","setLineDash","centerX","centerY","arc","PI","fill","text","fontSize","fillText"],"mappings":"iJACA,kCAaeA,sBAAQ,MANvB,SAA4BC,GAC1B,MAAO,CACLC,kBAAmB,SAACC,GAAD,OAAuBF,EAASC,YAAkBC,QAI1DH,CAAkCI,Y,2GCZ3CC,EACJ,WAAmBC,EAAkBC,GAAY,yBAA9BD,IAA6B,KAAXC,KAGlBC,E,WAsBnB,WACEC,EACAC,EACAC,GACC,yBAzBHC,YAyBE,OAvBFF,WAuBE,OAtBFG,cAAgB,EAsBd,KArBFC,kBAqBE,OApBFC,iBAoBE,OAlBFC,MAAO,EAkBL,KAhBFC,eAA0B,CACxB,IAAIZ,EAAM,EAAG,GACb,IAAIA,EAAM,EAAG,GACb,IAAIA,EAAM,EAAG,GACb,IAAIA,EAAM,EAAG,IAYb,KATFa,YASE,OARFC,cAAgB,EAQd,KANFR,aAME,EACAS,KAAKR,OAAS,IAAIS,IAAOZ,GAEzBW,KAAKR,OAAOU,eACV,EACA,EACAF,KAAKR,OAAOW,MACZH,KAAKR,OAAOY,OACZ,SAGFJ,KAAKV,MAAQA,EACbU,KAAKN,aAAL,SAAoB,EAAKJ,GACzBU,KAAKL,YAAL,SAAmBK,KAAKN,aAAgB,GACxCM,KAAKF,OAAS,IAAIO,MAAML,KAAKL,aAC7BK,KAAKT,QAAUA,EACfS,KAAKM,iB,4DAGSC,GAId,IAHA,IAAMC,EAAMR,KAAKH,eAAuB,EAARU,GAC1BE,EAAkB,IAAIxB,EAAMuB,EAAItB,EAAGsB,EAAIrB,GAEpCuB,EAAI,EAAGA,EAAIV,KAAKV,MAAOoB,IAAK,CACnCH,IAAU,EACV,IAAMI,EAAM,SAAG,EAAKD,GAEpB,OAAgB,EAARH,GACN,KAAK,EAAL,MAC2C,CACvCE,EAAgBtB,EAChBsB,EAAgBvB,GAFjBuB,EAAgBvB,EADnB,KACsBuB,EAAgBtB,EADtC,KAKE,MACF,KAAK,EACHsB,EAAgBtB,GAAKwB,EACrB,MACF,KAAK,EACHF,EAAgBvB,GAAKyB,EACrBF,EAAgBtB,GAAKwB,EACrB,MACF,KAAK,EAAL,MAC2C,CACvCA,EAAS,EAAIF,EAAgBtB,EAC7BwB,EAAS,EAAIF,EAAgBvB,GAF9BuB,EAAgBvB,EADnB,KACsBuB,EAAgBtB,EADtC,KAKEsB,EAAgBvB,GAAKyB,GAI3B,OAAOF,I,uCAMP,IAFA,IAAME,EAASX,KAAKR,OAAOY,OAASJ,KAAKN,aAEhCkB,EAAI,EAAGA,EAAIZ,KAAKL,YAAaiB,IAAK,CACzC,IAAMC,EAAQb,KAAKc,gBAAgBF,GACnCC,EAAM3B,GAAKyB,EACXE,EAAM1B,GAAKwB,EAGXE,EAAM3B,IAAMc,KAAKR,OAAOW,MAAQQ,GAAUX,KAAKN,aAAe,IAAM,EACpEmB,EAAM1B,IAAMa,KAAKR,OAAOY,OAASO,GAAUX,KAAKN,aAAe,IAAM,EAErEM,KAAKF,OAAOc,GAAKC,K,6BAKnB,IAAIb,KAAKJ,KAMT,IAHA,IAAImB,EAAOf,KAAKF,OAAO,GACfkB,EAAQC,KAARD,IAECJ,EAAI,EAAGA,EAAII,EAAIhB,KAAKD,cAAeC,KAAKF,OAAOa,QAASC,IAAK,CACpE,IAAMM,EAAUlB,KAAKF,OAAOc,GAC5BZ,KAAKR,OAAO2B,SACVJ,EAAK7B,EACL6B,EAAK5B,EACL+B,EAAQhC,EACRgC,EAAQ/B,EACRa,KAAKP,cACL,YAEFsB,EAAOG,K,+BAKLlB,KAAKJ,OAGTI,KAAKD,gBACDC,KAAKD,cAAgBC,KAAKF,OAAOa,SACnCX,KAAKJ,MAAO,EACZI,KAAKF,OAAS,S,sCCjIpB,mCA4Eed,UAnEf,SAAmBoC,GAAmB,IAC5BC,EAAiCD,EAAjCC,UAAWvC,EAAsBsC,EAAtBtC,kBACbwC,EAAWD,EAAUH,QACrBK,EAAcC,mBACpBD,EAAYL,SAAU,EAEtB,IAcMO,EAAiB,SAACnC,GAClBiC,EAAYL,UAGhBK,EAAYL,SAAU,EAlBR,SAAVQ,EAAWC,GACVJ,EAAYL,QAIbS,EAAQ/B,KACVgC,KAGFD,EAAQE,OACRF,EAAQG,SACRC,uBAAsB,kBAAML,EAAQC,OATlCA,EAAQ/B,MAAO,EAmBjB8B,CADgB,IAAItC,UAAuBkC,EAAUhC,GAAO,kBAIxDsC,EAAgB,WACpBL,EAAYL,SAAU,EAEtB,IADA,IAAIc,EAAKC,OAAOF,uBAAsB,eAC/BC,KACLC,OAAOC,qBAAqBF,IAI1BG,EAAiC,CACrCC,aAAc,CACZ,CACEC,MAAO,iBACPC,KAAM,eACNtB,IAAK,EACLuB,IAAK,EACLC,KAAM,EACNC,aAAc,EACdC,SAAU,SAACC,GACTf,IACAgB,YAAW,WACTnB,EAAekB,KACd,SAaX,OAPAE,qBAAU,WAER,OADA/D,EAAkBqD,GACX,WACLP,OAED,CAAC9C,EAAmBqD,IAEhB,uC,gCCzEM,SAASW,EAAgBC,EAAUC,GAChD,KAAMD,aAAoBC,GACxB,MAAM,IAAIC,UAAU,qCAFxB,mC,gCCAA,SAASC,EAAkBC,EAAQ/B,GACjC,IAAK,IAAIR,EAAI,EAAGA,EAAIQ,EAAMT,OAAQC,IAAK,CACrC,IAAIwC,EAAahC,EAAMR,GACvBwC,EAAWC,WAAaD,EAAWC,aAAc,EACjDD,EAAWE,cAAe,EACtB,UAAWF,IAAYA,EAAWG,UAAW,GACjDC,OAAOC,eAAeN,EAAQC,EAAWM,IAAKN,IAInC,SAASO,EAAaX,EAAaY,EAAYC,GAG5D,OAFID,GAAYV,EAAkBF,EAAYc,UAAWF,GACrDC,GAAaX,EAAkBF,EAAaa,GACzCb,EAbT,mC,sFCAqB/C,E,WAgBjB,WAAYT,GAA4B,yBAfhCA,YAe+B,OAd/BuE,mBAc+B,EACnC/D,KAAKgE,WAAahE,KAAKgE,WAAWC,KAAKjE,MACvCA,KAAKE,eAAiBF,KAAKE,eAAe+D,KAAKjE,MAC/CA,KAAKkE,gBAAkBlE,KAAKkE,gBAAgBD,KAAKjE,MACjDA,KAAKmB,SAAWnB,KAAKmB,SAAS8C,KAAKjE,MACnCA,KAAKmE,iBAAmBnE,KAAKmE,iBAAiBF,KAAKjE,MACnDA,KAAKgE,WAAahE,KAAKgE,WAAWC,KAAKjE,MACvCA,KAAKoE,UAAYpE,KAAKoE,UAAUH,KAAKjE,MAErCA,KAAKR,OAASA,EACdQ,KAAK+D,cACD/D,KAAKR,OAAO6E,WAAW,MAC3BrE,KAAKsE,Q,kEAvBL,OAAOtE,KAAKR,OAAO+E,0B,4BAInB,OAAOvE,KAAKR,OAAOW,Q,6BAInB,OAAOH,KAAKR,OAAOY,W,6CAmBnBJ,KAAK+D,cAAcS,aAAa,EAAG,EAAG,EAAG,EAAG,EAAG,K,iCAGxCC,EAA8BvF,EAAWC,EAAWuF,GAC3D1E,KAAK+D,cAAcY,OACnB3E,KAAK+D,cAAca,UAAU1F,EAAGC,GAChCa,KAAK+D,cAAcc,OAAOH,GAC1B1E,KAAK+D,cAAce,UAAUL,GAAYA,EAAUtE,MAAQ,GAAIsE,EAAUrE,OAAS,GAClFJ,KAAK+D,cAAcgB,Y,qCAGR7F,EAAWC,EAAWgB,EAAeC,EAAgB4E,GAChEhF,KAAK+D,cAAckB,UAAYD,EAC/BhF,KAAK+D,cAAcmB,SAAShG,EAAGC,EAAGgB,EAAOC,K,sCAG7BlB,EAAWC,EAAWgB,EAAeC,EAAgB4E,GACjEhF,KAAK+D,cAAcoB,YAAcH,EACjChF,KAAK+D,cAAcqB,WAAWlG,EAAGC,EAAGgB,EAAOC,K,sCAI3ClB,EAAWC,EAAWgB,EAAeC,EAAgBiF,EAAgBL,GAErEhF,KAAK+D,cAAcuB,YACnBtF,KAAK+D,cAAcoB,YAAcH,EACjChF,KAAK+D,cAAcwB,OAAOrG,EAAIiB,EAAQkF,EAAQlG,EAAIiB,GAClDJ,KAAK+D,cAAcyB,MAAMtG,EAAGC,EAAIiB,EAAQlB,EAAGC,EAAGkG,GAC9CrF,KAAK+D,cAAcyB,MAAMtG,EAAGC,EAAGD,EAAIiB,EAAOhB,EAAGkG,GAC7CrF,KAAK+D,cAAcyB,MAAMtG,EAAIiB,EAAOhB,EAAGD,EAAIiB,EAAOhB,EAAIiB,EAAQiF,GAC9DrF,KAAK+D,cAAcyB,MAAMtG,EAAIiB,EAAOhB,EAAIiB,EAAQlB,EAAGC,EAAIiB,EAAQiF,GAC/DrF,KAAK+D,cAAc0B,W,+BAGdC,EAAYC,EAAYC,EAAYC,EAAYC,EAAmBd,GACxEhF,KAAK+D,cAAcY,OACnB3E,KAAK+D,cAAcuB,YACnBtF,KAAK+D,cAAc+B,UAAYA,EAC/B9F,KAAK+D,cAAcoB,YAAcH,EACjChF,KAAK+D,cAAcwB,OAAOG,EAAIC,GAC9B3F,KAAK+D,cAAcgC,OAAOH,EAAIC,GAC9B7F,KAAK+D,cAAc0B,SACnBzF,KAAK+D,cAAcgB,Y,qCAGRW,EAAYC,EAAYC,EAAYC,EAAYC,EAAmBd,EAAegB,GAC7FhG,KAAK+D,cAAckC,YAAYD,GAC/BhG,KAAKmB,SAASuE,EAAIC,EAAIC,EAAIC,EAAIC,EAAWd,GACzChF,KAAK+D,cAAckC,YAAY,M,uCAGlBC,EAAiBC,EAAiBd,EAAgBL,GAC/DhF,KAAK+D,cAAcuB,YACnBtF,KAAK+D,cAAckB,UAAYD,EAC/BhF,KAAK+D,cAAcqC,IAAIF,EAASC,EAASd,EAAQ,EAAG,EAAIpE,KAAKoF,IAAI,GACjErG,KAAK+D,cAAcuC,S,gCAGbC,EAAcrH,EAAWC,EAAWqH,EAAkBxB,GAC5DhF,KAAK+D,cAAckB,UAAYD,EAC/BhF,KAAK+D,cAAc0C,SAASF,EAAMrH,EAAGC,K,gCAG/BD,EAAWC,GACjBa,KAAK+D,cAAca,UAAU1F,EAAGC,K,6BAG7BuF,GACH1E,KAAK+D,cAAcc,OAAOH,K,kCAI1B1E,KAAK+D,cAAcY,S,iCAInB3E,KAAK+D,cAAcgB,c","file":"static/js/7.8f87cd69.chunk.js","sourcesContent":["import { Dispatch } from \"redux\";\nimport { connect } from \"react-redux\";\n\nimport DataAttributes from \"src/models/data-attributes\";\nimport { setDataAttributes } from \"src/redux-impl/data-attributes/actions\";\n\nimport Component from \"./component\";\n\nfunction mapDispatchToProps(dispatch: Dispatch) {\n  return {\n    setDataAttributes: (v: DataAttributes) => dispatch(setDataAttributes(v)),\n  };\n}\n\nexport default connect(null, mapDispatchToProps)(Component);\n","import Canvas from \"src/models/canvas\";\n\nclass Point {\n  constructor(public x: number, public y: number) {}\n}\n\nexport default class HilbertCurveController {\n  canvas: Canvas;\n\n  order: number;\n  lineThickness = 1;\n  squaresCount: number;\n  totalPoints: number;\n\n  done = false;\n\n  hilbertIndices: Point[] = [\n    new Point(0, 0),\n    new Point(0, 1),\n    new Point(1, 1),\n    new Point(1, 0),\n  ];\n\n  points: Point[];\n  framesCounter = 0;\n\n  stopper: () => void;\n\n  constructor(\n    canvasElement: HTMLCanvasElement,\n    order: number,\n    stopper: () => void\n  ) {\n    this.canvas = new Canvas(canvasElement);\n    // Draw background\n    this.canvas.drawFilledRect(\n      0,\n      0,\n      this.canvas.width,\n      this.canvas.height,\n      \"white\"\n    );\n\n    this.order = order;\n    this.squaresCount = 2 ** order;\n    this.totalPoints = this.squaresCount ** 2;\n    this.points = new Array(this.totalPoints);\n    this.stopper = stopper;\n    this.generatePoints();\n  }\n\n  getHilbertIndex(index: number) {\n    const ref = this.hilbertIndices[index & 3];\n    const firstOrderPoint = new Point(ref.x, ref.y);\n\n    for (let j = 1; j < this.order; j++) {\n      index >>= 2;\n      const length = 2 ** j;\n\n      switch (index & 3) {\n        case 0:\n          [firstOrderPoint.x, firstOrderPoint.y] = [\n            firstOrderPoint.y,\n            firstOrderPoint.x,\n          ];\n          break;\n        case 1:\n          firstOrderPoint.y += length;\n          break;\n        case 2:\n          firstOrderPoint.x += length;\n          firstOrderPoint.y += length;\n          break;\n        case 3:\n          [firstOrderPoint.x, firstOrderPoint.y] = [\n            length - 1 - firstOrderPoint.y,\n            length - 1 - firstOrderPoint.x,\n          ];\n          firstOrderPoint.x += length;\n      }\n    }\n\n    return firstOrderPoint;\n  }\n\n  generatePoints() {\n    const length = this.canvas.height / this.squaresCount;\n\n    for (let i = 0; i < this.totalPoints; i++) {\n      const point = this.getHilbertIndex(i);\n      point.x *= length;\n      point.y *= length;\n\n      // Offset\n      point.x += (this.canvas.width - length * (this.squaresCount - 1)) / 2;\n      point.y += (this.canvas.height - length * (this.squaresCount - 1)) / 2;\n\n      this.points[i] = point;\n    }\n  }\n\n  plot() {\n    if (this.done) {\n      return;\n    }\n    let prev = this.points[0];\n    const { min } = Math;\n\n    for (let i = 1; i < min(this.framesCounter, this.points.length); i++) {\n      const current = this.points[i];\n      this.canvas.drawLine(\n        prev.x,\n        prev.y,\n        current.x,\n        current.y,\n        this.lineThickness,\n        \"darkblue\"\n      );\n      prev = current;\n    }\n  }\n\n  update() {\n    if (this.done) {\n      return;\n    }\n    this.framesCounter++;\n    if (this.framesCounter > this.points.length) {\n      this.done = true;\n      this.points = [];\n    }\n  }\n}\n","import React, { useEffect, useRef } from \"react\";\nimport DataAttributes from \"src/models/data-attributes\";\nimport HilbertCurveController from \"src/illustrations/pseudo-hilbert-curve/controller\";\n\ntype PropsType = {\n  canvasRef: React.RefObject<HTMLCanvasElement>;\n  setDataAttributes: (v: DataAttributes) => void;\n};\n\nfunction Component(props: PropsType) {\n  const { canvasRef, setDataAttributes } = props;\n  const canvasEl = canvasRef.current as HTMLCanvasElement;\n  const isAnimating = useRef<boolean>();\n  isAnimating.current = false;\n\n  const animate = (program: HilbertCurveController) => {\n    if (!isAnimating.current) {\n      program.done = true;\n      return;\n    }\n    if (program.done) {\n      animationStop();\n      return;\n    }\n    program.plot();\n    program.update();\n    requestAnimationFrame(() => animate(program));\n  };\n\n  const animationStart = (order: number) => {\n    if (isAnimating.current) {\n      return;\n    }\n    isAnimating.current = true;\n\n    const program = new HilbertCurveController(canvasEl, order, () => {});\n    animate(program);\n  };\n\n  const animationStop = () => {\n    isAnimating.current = false;\n    let id = window.requestAnimationFrame(function () {});\n    while (id--) {\n      window.cancelAnimationFrame(id);\n    }\n  };\n\n  const dataAttributes: DataAttributes = {\n    numberInputs: [\n      {\n        title: \"Order of curve\",\n        note: \"Maximum is 6\",\n        min: 1,\n        max: 6,\n        step: 1,\n        currentValue: 5,\n        onChange: (value: number) => {\n          animationStop();\n          setTimeout(() => {\n            animationStart(value);\n          }, 100);\n        },\n      },\n    ],\n  };\n\n  useEffect(() => {\n    setDataAttributes(dataAttributes);\n    return () => {\n      animationStop();\n    };\n  }, [setDataAttributes, dataAttributes]);\n\n  return <></>;\n}\n\nexport default Component;\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default class Canvas {\n    private canvas: HTMLCanvasElement;\n    private canvasContext: CanvasRenderingContext2D;\n\n    get getBoundingClientRect() {\n        return this.canvas.getBoundingClientRect();\n    }\n\n    get width(): number {\n        return this.canvas.width;\n    }\n\n    get height(): number {\n        return this.canvas.height;\n    }\n\n    constructor(canvas: HTMLCanvasElement) {\n        this.drawBitmap = this.drawBitmap.bind(this);\n        this.drawFilledRect = this.drawFilledRect.bind(this);\n        this.drawOutlineRect = this.drawOutlineRect.bind(this);\n        this.drawLine = this.drawLine.bind(this);\n        this.drawFilledCircle = this.drawFilledCircle.bind(this);\n        this.drawBitmap = this.drawBitmap.bind(this);\n        this.writeText = this.writeText.bind(this);\n\n        this.canvas = canvas;\n        this.canvasContext =\n            this.canvas.getContext('2d') as CanvasRenderingContext2D;\n        this.reset();\n    }\n\n    reset() {\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n    }\n\n    drawBitmap(useBitmap: CanvasImageSource, x: number, y: number, angle: number) {\n        this.canvasContext.save();\n        this.canvasContext.translate(x, y);\n        this.canvasContext.rotate(angle);\n        this.canvasContext.drawImage(useBitmap, -useBitmap.width / 2, -useBitmap.height / 2);\n        this.canvasContext.restore();\n    }\n\n    drawFilledRect(x: number, y: number, width: number, height: number, color: string) {\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.fillRect(x, y, width, height);\n    }\n\n    drawOutlineRect(x: number, y: number, width: number, height: number, color: string) {\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.strokeRect(x, y, width, height);\n    }\n\n    drawRoundedRect(\n        x: number, y: number, width: number, height: number, radius: number, color: string\n    ) {\n        this.canvasContext.beginPath();\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.moveTo(x + width - radius, y + height);\n        this.canvasContext.arcTo(x, y + height, x, y, radius);\n        this.canvasContext.arcTo(x, y, x + width, y, radius);\n        this.canvasContext.arcTo(x + width, y, x + width, y + height, radius);\n        this.canvasContext.arcTo(x + width, y + height, x, y + height, radius);\n        this.canvasContext.stroke();\n    }\n\n    drawLine(x1: number, y1: number, x2: number, y2: number, lineWidth: number, color: string) {\n        this.canvasContext.save();\n        this.canvasContext.beginPath();\n        this.canvasContext.lineWidth = lineWidth;\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.moveTo(x1, y1);\n        this.canvasContext.lineTo(x2, y2);\n        this.canvasContext.stroke();\n        this.canvasContext.restore();\n    }\n\n    drawDashedLine(x1: number, y1: number, x2: number, y2: number, lineWidth: number, color: string, dashParams: number[]) {\n        this.canvasContext.setLineDash(dashParams);\n        this.drawLine(x1, y1, x2, y2, lineWidth, color);\n        this.canvasContext.setLineDash([]);\n    }\n\n    drawFilledCircle(centerX: number, centerY: number, radius: number, color: string) {\n        this.canvasContext.beginPath();\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.arc(centerX, centerY, radius, 0, 2 * Math.PI, true);\n        this.canvasContext.fill();\n    }\n\n    writeText(text: string, x: number, y: number, fontSize: number, color: string) {\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.fillText(text, x, y);\n    }\n\n    translate(x: number, y: number) {\n        this.canvasContext.translate(x, y);\n    }\n\n    rotate(angle: number) {\n        this.canvasContext.rotate(angle);\n    }\n\n    pushState() {\n        this.canvasContext.save();\n    }\n\n    popState() {\n        this.canvasContext.restore();\n    }\n}\n\n\n// Mouse handler\n// let mouseX, mouseY;\n// canvas-container.addEventListener('mousemove', function (event) {\n//         let rect = canvas-container.getBoundingClientRect();\n//         let root = document.documentElement;\n\n//         mouseX = event.clientX - rect.left - root.scrollLeft;\n//         mouseY = event.clientY - rect.top - root.scrollTop;\n//     });\n"],"sourceRoot":""}