{"version":3,"sources":["illustrations/pong-game/controller.ts","illustrations/pong-game/component.tsx","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js","models/canvas.ts"],"names":["PongGameController","e","canvas","interval","setTimeout","playerScore","computerScore","gameRunning","backgroundColor","outlineColor","homeScreenTextColor","userScoreColor","compScoreColor","paddleWidth","paddleHeight","paddleColor","offset","scoreToWin","pauseTimeDurationInSeconds","maxAbsoluteBallVelocity","paddleUser","x","y","paddleComp","ball","width","height","velocityX","velocityY","color","this","Canvas","reset","setInterval","render","bind","clearInterval","timeRemaining","writePauseTimeRemaining","pauseTimer","start","drawFilledRect","writeText","drawBackground","renderGame","updateGameState","renderStartScreen","event","getBoundingClientRect","root","document","documentElement","clientY","top","scrollTop","boundYCoordinate","point","Math","min","max","stop","drawOutlineRect","winnerText","winnerTextColor","t3","t4","sBY","sBX","drawPaddles","drawBall","writeScore","handleWallCollision","handlePaddleCollision","computerMovement","pause","swapBallYVelocity","drawLine","t1","t2","Component","props","canvasEl","canvasRef","current","component","focus","tabIndex","addEventListener","key","onEnterPress","onEscapePress","onHover","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","_createClass","protoProps","staticProps","prototype","canvasContext","drawBitmap","drawFilledCircle","getContext","setTransform","useBitmap","angle","save","translate","rotate","drawImage","restore","fillStyle","fillRect","strokeStyle","strokeRect","radius","beginPath","moveTo","arcTo","stroke","x1","y1","x2","y2","lineWidth","lineTo","dashParams","setLineDash","centerX","centerY","arc","PI","fill","text","fontSize","fillText"],"mappings":"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","file":"static/js/19.f7a7f6f2.chunk.js","sourcesContent":["import Canvas from \"src/models/canvas\";\n\ninterface Point {\n  x: number;\n  y: number;\n}\n\nexport class PongGameController {\n  private readonly canvas: Canvas;\n  private interval = setTimeout(() => {}, 0);\n\n  private playerScore = 0;\n  private computerScore = 0;\n\n  private gameRunning = false;\n\n  private readonly backgroundColor = \"white\";\n  private readonly outlineColor = \"black\";\n  private readonly homeScreenTextColor = \"black\";\n  private readonly userScoreColor = \"green\";\n  private readonly compScoreColor = \"red\";\n\n  private readonly paddleWidth = 7;\n  private readonly paddleHeight = 70;\n  private readonly paddleColor = \"red\";\n  private readonly offset = 20; // border width\n\n  private readonly scoreToWin = 5;\n  private readonly pauseTimeDurationInSeconds = 3;\n\n  private readonly maxAbsoluteBallVelocity = 2.5;\n  private paddleUser: Point = { x: 20, y: 0 };\n  private paddleComp: Point = { x: 0, y: 0 };\n  private ball = {\n    x: 0,\n    y: 0,\n    width: 10,\n    height: 10,\n    velocityX: 1,\n    velocityY: 0.3,\n    color: \"blue\",\n  };\n\n  constructor(e: HTMLCanvasElement) {\n    this.canvas = new Canvas(e);\n\n    this.paddleComp.x =\n      this.canvas.width - this.paddleWidth - this.paddleUser.x;\n    this.paddleUser.y = this.paddleComp.y =\n      (this.canvas.height - this.paddleHeight) / 2;\n\n    this.ball.x = (this.canvas.width - this.ball.width) / 2;\n    this.ball.y = (this.canvas.height - this.ball.width) / 2;\n  }\n\n  reset() {\n    this.ball.x = this.canvas.width / 2;\n    this.ball.y = this.canvas.height / 2;\n\n    this.ball.velocityY = 0.3;\n  }\n\n  start() {\n    this.reset();\n    this.interval = setInterval(this.render.bind(this), 1000 / 300);\n  }\n\n  stop() {\n    this.gameRunning = false;\n    clearInterval(this.interval);\n    this.render();\n  }\n\n  pause() {\n    this.reset();\n    clearInterval(this.interval);\n    this.render();\n\n    if (\n      this.playerScore === this.scoreToWin ||\n      this.computerScore === this.scoreToWin\n    ) {\n      return;\n    }\n\n    // Pause time printer\n    let timeRemaining = this.pauseTimeDurationInSeconds;\n    this.writePauseTimeRemaining(timeRemaining--);\n    const pauseTimer = setInterval(() => {\n      this.writePauseTimeRemaining(timeRemaining);\n      timeRemaining--;\n    }, 1000);\n\n    // Resume game after 'n' seconds\n    setTimeout(() => {\n      this.start();\n      clearInterval(pauseTimer);\n    }, 1000 * this.pauseTimeDurationInSeconds);\n  }\n\n  writePauseTimeRemaining(timeRemaining: number) {\n    const { canvas, backgroundColor } = this;\n    const { width, height } = this.canvas;\n\n    // clear background\n    canvas.drawFilledRect(\n      width / 2 - 7,\n      height / 2 - 125,\n      30,\n      30,\n      backgroundColor\n    );\n    // write text\n    canvas.writeText(\n      `${timeRemaining}`,\n      width / 2,\n      height / 2 - 100,\n      35,\n      this.homeScreenTextColor\n    );\n  }\n\n  render() {\n    this.drawBackground();\n    if (this.gameRunning) {\n      this.renderGame();\n      this.updateGameState();\n    } else {\n      this.renderStartScreen();\n      clearInterval(this.interval);\n    }\n  }\n\n  onHover(event: MouseEvent) {\n    if (this.canvas) {\n      const canvas = this.canvas.getBoundingClientRect;\n      const root = document.documentElement;\n      this.paddleUser.y =\n        event.clientY - canvas.top - root.scrollTop - this.paddleHeight / 2;\n      this.boundYCoordinate(this.paddleUser);\n    }\n  }\n\n  computerMovement() {\n    if (this.ball.y > this.paddleComp.y + this.paddleHeight / 2) {\n      this.paddleComp.y++;\n    } else if (this.ball.y < this.paddleComp.y + this.paddleHeight / 2) {\n      this.paddleComp.y--;\n    }\n    this.boundYCoordinate(this.paddleComp);\n  }\n\n  boundYCoordinate(point: Point) {\n    const { height } = this.canvas;\n    const { offset, paddleHeight } = this;\n    point.y = Math.min(point.y, height - offset - paddleHeight);\n    point.y = Math.max(point.y, offset);\n  }\n\n  onEnterPress() {\n    if (!this.gameRunning) {\n      this.playerScore = 0;\n      this.computerScore = 0;\n      this.start();\n    }\n    this.gameRunning = true;\n  }\n\n  onEscapePress() {\n    this.stop();\n  }\n\n  drawBackground() {\n    const { offset, backgroundColor, outlineColor } = this;\n    const { width, height } = this.canvas;\n\n    this.canvas.drawFilledRect(0, 0, width, height, backgroundColor);\n    this.canvas.drawOutlineRect(\n      offset,\n      offset,\n      width - 2 * offset,\n      height - 2 * offset,\n      outlineColor\n    );\n  }\n\n  renderStartScreen() {\n    // text\n    const t1 = \"Click on the canvas and hit 'Enter' to start\";\n    const t3 = `Your score: ${this.playerScore}`;\n    const t4 = `AI score: ${this.computerScore}`;\n\n    const sBX = 210; // scoreBoardX\n    const sBY = 160; // scoreBoardY\n\n    const {\n      homeScreenTextColor,\n      userScoreColor,\n      compScoreColor,\n      playerScore,\n      computerScore,\n    } = this;\n\n    this.canvas.writeText(t1, 140, sBY - 20, 30, homeScreenTextColor);\n\n    if (playerScore !== computerScore) {\n      let winnerText;\n      let winnerTextColor;\n      if (playerScore > computerScore) {\n        winnerText = \"PLAYER WINS!\";\n        winnerTextColor = userScoreColor;\n      } else {\n        winnerText = \"COMPUTER WINS!\";\n        winnerTextColor = compScoreColor;\n      }\n      this.canvas.writeText(winnerText, sBX - 10, sBY, 30, winnerTextColor);\n      this.canvas.writeText(t3, sBX, sBY + 20, 20, userScoreColor);\n      this.canvas.writeText(t4, sBX + 5, sBY + 40, 20, compScoreColor);\n    }\n  }\n\n  renderGame() {\n    this.drawPaddles();\n    this.drawBall();\n    this.writeScore();\n  }\n\n  updateGameState() {\n    this.ball.x += this.ball.velocityX;\n    this.ball.y += this.ball.velocityY;\n\n    this.handleWallCollision();\n    this.handlePaddleCollision();\n    this.computerMovement();\n\n    const { playerScore, scoreToWin, computerScore } = this;\n    if (playerScore === scoreToWin || computerScore === scoreToWin) {\n      this.stop();\n    }\n  }\n\n  handleWallCollision() {\n    // bottom\n    if (this.ball.y + this.ball.height >= this.canvas.height - this.offset) {\n      this.ball.velocityY *= -1;\n    }\n\n    // top\n    if (this.ball.y <= this.offset) {\n      this.ball.velocityY *= -1;\n    }\n\n    // right\n    if (this.ball.x + this.ball.width >= this.canvas.width - this.offset) {\n      this.playerScore++;\n      this.pause();\n    }\n\n    // left\n    if (this.ball.x <= this.offset) {\n      this.computerScore++;\n      this.pause();\n    }\n  }\n\n  handlePaddleCollision() {\n    const {\n      ball,\n      paddleUser,\n      paddleComp,\n      paddleHeight,\n      paddleWidth,\n      offset,\n      canvas,\n      maxAbsoluteBallVelocity,\n    } = this;\n\n    const swapBallYVelocity = () => {\n      ball.velocityX *= -1;\n      ball.velocityY = ((ball.y - (paddleUser.y + paddleHeight / 2)) * 4) / 75;\n      ball.velocityY = Math.max(ball.velocityY, -maxAbsoluteBallVelocity);\n      ball.velocityY = Math.min(ball.velocityY, maxAbsoluteBallVelocity);\n    };\n\n    // collision with user's paddle\n    if (ball.x <= offset + paddleWidth) {\n      if (\n        ball.y >= paddleUser.y &&\n        ball.y + ball.height <= paddleUser.y + paddleHeight\n      ) {\n        swapBallYVelocity();\n      }\n    }\n\n    // collision with computer's paddle\n    if (ball.x + ball.width >= canvas.width - offset - paddleWidth) {\n      if (\n        ball.y >= paddleComp.y &&\n        ball.y + ball.height <= paddleComp.y + paddleHeight\n      ) {\n        swapBallYVelocity();\n      }\n    }\n  }\n\n  drawPaddles() {\n    const { paddleWidth, paddleHeight, paddleColor } = this;\n    {\n      const { x, y } = this.paddleUser;\n      this.canvas.drawFilledRect(x, y, paddleWidth, paddleHeight, paddleColor);\n    }\n    {\n      const { x, y } = this.paddleComp;\n      this.canvas.drawFilledRect(x, y, paddleWidth, paddleHeight, paddleColor);\n    }\n    {\n      // Paddle-like borders\n      const { offset } = this;\n      const { width, height } = this.canvas;\n\n      this.canvas.drawLine(\n        offset,\n        offset,\n        width - offset,\n        offset,\n        1,\n        paddleColor\n      );\n      this.canvas.drawLine(\n        offset,\n        height - offset,\n        width - offset,\n        height - offset,\n        1,\n        paddleColor\n      );\n    }\n  }\n\n  drawBall() {\n    const { x, y, width, height, color } = this.ball;\n    this.canvas.drawFilledRect(x, y, width, height, color);\n  }\n\n  writeScore() {\n    // text\n    const t1 = `Player score: ${this.playerScore}`;\n    const t2 = `AI score: ${this.computerScore}`;\n    const t3 = `${this.scoreToWin} TO WIN`;\n\n    this.canvas.writeText(t1, 18, 15, 15, this.homeScreenTextColor);\n    this.canvas.writeText(t2, 430, 15, 15, this.homeScreenTextColor);\n    this.canvas.writeText(t3, 230, 15, 15, this.homeScreenTextColor);\n  }\n}\n","import React from \"react\";\nimport DataAttributes from \"src/models/data-attributes\";\nimport { PongGameController } from \"src/illustrations/pong-game/controller\";\n\ntype PropsType = {\n  canvasRef: React.RefObject<HTMLCanvasElement>;\n  setDataAttributes: (v: DataAttributes) => void;\n};\n\nfunction Component(props: PropsType) {\n  const canvasEl = props.canvasRef.current as HTMLCanvasElement;\n  const component = new PongGameController(canvasEl);\n  canvasEl.focus();\n  canvasEl.tabIndex = 1;\n  component.start();\n\n  canvasEl.addEventListener(\"keyup\", (event) => {\n    if (event.key === \"Enter\") {\n      component.onEnterPress();\n    } else if (event.key === \"Escape\") {\n      component.onEscapePress();\n    }\n  });\n\n  canvasEl.addEventListener(\"mousemove\", (event: MouseEvent) => {\n    component.onHover(event);\n  });\n\n  return <></>;\n}\n\nexport default Component;\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","export default class Canvas {\n    private canvas: HTMLCanvasElement;\n    private canvasContext: CanvasRenderingContext2D;\n\n    get getBoundingClientRect() {\n        return this.canvas.getBoundingClientRect();\n    }\n\n    get width(): number {\n        return this.canvas.width;\n    }\n\n    get height(): number {\n        return this.canvas.height;\n    }\n\n    constructor(canvas: HTMLCanvasElement) {\n        this.drawBitmap = this.drawBitmap.bind(this);\n        this.drawFilledRect = this.drawFilledRect.bind(this);\n        this.drawOutlineRect = this.drawOutlineRect.bind(this);\n        this.drawLine = this.drawLine.bind(this);\n        this.drawFilledCircle = this.drawFilledCircle.bind(this);\n        this.drawBitmap = this.drawBitmap.bind(this);\n        this.writeText = this.writeText.bind(this);\n\n        this.canvas = canvas;\n        this.canvasContext =\n            this.canvas.getContext('2d') as CanvasRenderingContext2D;\n        this.reset();\n    }\n\n    reset() {\n        this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n    }\n\n    drawBitmap(useBitmap: CanvasImageSource, x: number, y: number, angle: number) {\n        this.canvasContext.save();\n        this.canvasContext.translate(x, y);\n        this.canvasContext.rotate(angle);\n        this.canvasContext.drawImage(useBitmap, -useBitmap.width / 2, -useBitmap.height / 2);\n        this.canvasContext.restore();\n    }\n\n    drawFilledRect(x: number, y: number, width: number, height: number, color: string) {\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.fillRect(x, y, width, height);\n    }\n\n    drawOutlineRect(x: number, y: number, width: number, height: number, color: string) {\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.strokeRect(x, y, width, height);\n    }\n\n    drawRoundedRect(\n        x: number, y: number, width: number, height: number, radius: number, color: string\n    ) {\n        this.canvasContext.beginPath();\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.moveTo(x + width - radius, y + height);\n        this.canvasContext.arcTo(x, y + height, x, y, radius);\n        this.canvasContext.arcTo(x, y, x + width, y, radius);\n        this.canvasContext.arcTo(x + width, y, x + width, y + height, radius);\n        this.canvasContext.arcTo(x + width, y + height, x, y + height, radius);\n        this.canvasContext.stroke();\n    }\n\n    drawLine(x1: number, y1: number, x2: number, y2: number, lineWidth: number, color: string) {\n        this.canvasContext.save();\n        this.canvasContext.beginPath();\n        this.canvasContext.lineWidth = lineWidth;\n        this.canvasContext.strokeStyle = color;\n        this.canvasContext.moveTo(x1, y1);\n        this.canvasContext.lineTo(x2, y2);\n        this.canvasContext.stroke();\n        this.canvasContext.restore();\n    }\n\n    drawDashedLine(x1: number, y1: number, x2: number, y2: number, lineWidth: number, color: string, dashParams: number[]) {\n        this.canvasContext.setLineDash(dashParams);\n        this.drawLine(x1, y1, x2, y2, lineWidth, color);\n        this.canvasContext.setLineDash([]);\n    }\n\n    drawFilledCircle(centerX: number, centerY: number, radius: number, color: string) {\n        this.canvasContext.beginPath();\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.arc(centerX, centerY, radius, 0, 2 * Math.PI, true);\n        this.canvasContext.fill();\n    }\n\n    writeText(text: string, x: number, y: number, fontSize: number, color: string) {\n        this.canvasContext.fillStyle = color;\n        this.canvasContext.fillText(text, x, y);\n    }\n\n    translate(x: number, y: number) {\n        this.canvasContext.translate(x, y);\n    }\n\n    rotate(angle: number) {\n        this.canvasContext.rotate(angle);\n    }\n\n    pushState() {\n        this.canvasContext.save();\n    }\n\n    popState() {\n        this.canvasContext.restore();\n    }\n}\n\n\n// Mouse handler\n// let mouseX, mouseY;\n// canvas-container.addEventListener('mousemove', function (event) {\n//         let rect = canvas-container.getBoundingClientRect();\n//         let root = document.documentElement;\n\n//         mouseX = event.clientX - rect.left - root.scrollLeft;\n//         mouseY = event.clientY - rect.top - root.scrollTop;\n//     });\n"],"sourceRoot":""}